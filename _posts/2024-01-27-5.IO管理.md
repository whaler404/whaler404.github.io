---
layout: post
title:  5.输入输出（I/O）管理
# subtitle: 
date:   2024-01-27
author: fzy
header-img: img/post-bg-playphone.jpg
categories: post course
catalog: true
tags:
    - course
    - os
---

# 输入输出（I/O）管理

## 5.1 I/O管理概述

### I/O设备

#### 设备分类

按照**信息交换**的单位分：

- **块设备：**以**数据块**作为信息交换的单位，属于有结构型设备。传输速率高、可寻址、随机读写。
- **字符设备：**以**字节**为单位，无结构，速率低，不可寻址，常采用中断I/O方式。传输速率低、不可寻址、不支持随机读写。

按照**传输速率**分

- **低速设备：**键盘、鼠标
- **中速设备：**打印机
- **高速设备：**磁盘

#### **IO接口**

IO接口就是<u>**设备控制器**</u>，位于CPU和设备之间。与cpu和设备通信。

<img src="/assets/images/os.assets/image-20230612153536491.png" alt="image-20230612153536491" style="zoom:67%;" />

- **设备控制器与CPU的接口：**包含数据线，地址线和控制线。数据寄存器，状态寄存器，控制寄存器（三线三端口）
- **设备控制器和设备的接口：**多个设备接口，每个接口都存在数据、控制和状态三种信号。
- **IO逻辑：**用于实现对**设备的控制**。对CPU发送的命令和地址。

设备控制器的主要功能：

- **接受识别CPU发来的命令**（控制寄存器）
- **数据交换**（数据寄存器）
- **标识和报告设备状态**（状态寄存器）
- **地址识别、数据缓冲、差错控制**（地址线、数据线、控制线）

#### IO端口

<u>指的是设备控制器中可以被CPU直接访问的**寄存器**。</u>

- **数据寄存器：**数据缓冲
- **状态寄存器：**获取执行结果和设备的状态信息
- **控制寄存器：**由CPU写入

为了实现CPU和IO端口的通信，有两种编制方式：；

- **独立编址**：每一个端口分配一个端口号，组成**端口空间**，操作系统使用特殊的I/O指令才可以访问端口空间
- **统一编制**：每个端口**映射唯一的内存地址**。在地址空间的顶端
- 混合编址：数据缓冲区放在内存、独立的io地址空间

#### IO控制方式

设备管理的主要任务：在CPU、内存和控制设备之间传输数据

##### 程序直接控制方式

不采用中断机制，**CPU**绝大部分时间在**等待IO设备完成数据IO的循环测试**，I/O无法向CPU报告IO的结束。CPU和IO只能串行工作。

##### 中断驱动方式

**允许IO设备主动打断CPU的运行并请求服务**，CPU向控制器发送命令后可以做其他工作。

从IO控制器的角度，IO从CPU接收命令，外部设备和数据寄存器数据交换，**结束后**，通过控制线发送**中断信号**，等待CPU进一步操作。

从CPU的角度，CPU发出命令，**保存当前**进程A上下文，转去其他进程B，每个指令周期末都要**检查中断**，发现有IO控制器的中断，保存B的上下文，**恢复A的上下文**，继续运行。

> 中断驱动方式弥补了CPU和外部设备的速度差异。

但是数据的**每个字**的传输都**必须经过CPU**，仍然会**消耗很多CPU时间**。

精确中断：机器停留在明确状态的中断

不精确中断

##### **DMA方式**

<u>在**IO设备和内存**之间直接开辟**数据交换**通路，让数据不用经过CPU寄存器，直接读到内存。</u>**CPU**只在传输一个或者多个数据块的**开始和结束**的时候才要**干活（发生中断）**。基本单位是数据块。

DMA寄存器：命令/状态寄存器、内存地址寄存器、数据寄存器、数据计数器

> 中断方式传输每个数据要中断CPU，DMA传输一批数据结束才中断CPU

<img src="/assets/images/os.assets/image-20230612160258389.png" alt="image-20230612160258389" style="zoom:80%;" />

<img src="/assets/images/os.assets/image-20230612160320416.png" alt="image-20230612160320416" style="zoom:50%;" />

##### 通道控制方式

DMA方式的拓展，进一步减少CPU干预。

#### **IO软件层次结构**

每层**利用下层**提供的服务，屏蔽功能的实现细节，**向上层提供**服务。只要层次间接口不变，代码修改不会引起上下层代码变更。

<img src="/assets/images/os.assets/image-20230612161036722.png" alt="image-20230612161036722" style="zoom:80%;" />

1. **用户层IO软件：**实现和**用户交互**的接口，在操作系统内部或用户层的库函数，用户可以直接调用

2. **设备独立性软件：**实现**用户程序**和**设备驱动器**的**统一接口**，执行所有设备的**公有操作**

   > 将系统调用参数转化为设备操作命令

3. **设备驱动程序：**与**硬件直接相关**，实现系统的操作指令，IO进程与设备控制器之间的通信程序，以**进程**的形式存在，**封装**设备的**具体差别**，向上提供标准接口。每类设备对应**一个**设备驱动程序。

4. **中断处理程序：**用于保存被中断的CPU环境，转入中断处理程序进行处理，恢复现场

> 设备独立性：让**程序独立于**具体使用的**物理设备**。为此引入了**逻辑设备和物理设备**的概念。在应用中用**逻辑设备名请求某类设备**，在实际执行的时候将逻辑设备名**转换为物理设备名**。
>
> 逻辑设备名的好处：增加设备分配的灵活性，易于实现IO重定向

## 5.2 设备独立性软件

**磁盘高速缓冲：**磁盘缓冲技术指的是<u>利用**内存中的存储空间**来暂存从磁盘中读取的一系列盘块中的信息。</u><u>磁盘高速缓存从**逻辑上属于硬盘**，**物理上则是驻留在内存**中的盘块</u>。有两种实现形式：一种是在内存中开辟一个**单独的空间作为高速缓存**，另一种是利用**未被利用的空间作为缓冲池**。

**缓冲区：**引入缓冲区主要为了：

- **缓和**CPU和IO设备之间**速度不匹配**的问题。
- **减少**对CPU的**中断频率**。
- **提高**CPU和IO设备之间的**并行性**。

缓冲技术分为：

- 单缓冲：写入写出等待
- 双缓冲：装满才装另一个
- 循环缓冲：缓冲区成环

> 这里应该不用详细了解具体的缓冲技术，只要知道缓冲技术大概是干什么的就可以了。

![image-20230613091049372](/assets/images/os.assets/image-20230613091049372.png)

### 设备的分配和回收

有三种设备的使用方式:

- **独占式使用设备**
- **分时共享使用设备：**分时共享使用
- **以SPOOLING方式使用外部设备：**虚拟设备的功能，对设备IO批处理

设备分配的数据结构：（初步认为不是很重要）

- 设备控制表（DCT）：一个设备控制表就表征一个**设备**。控制表中的表项就是设备的各个**属性**
- 控制器控制表（COCT）：表征**设备控制器的属性**
- 系统设备表（SDT）：表征连接到系统的**所有物理设备**情况
- 通道控制表（CHCT)：表征一个通道

**设备分配的策略：**要充分**发挥设备的效率**，又要**避免死锁**。

分为**静态分配**和**动态分配**两种：**静态**分配就是作业在开始执行的时候就**一次性申请**全部资源，**动态**分配就是**边运行边申请资源**。<u>（结合死锁部分理解）</u>

从逻辑设备名到物理设备名的映射：在系统中设置一个逻辑设备表，将逻辑设备名映射为物理设备名。

### **SPOOLING技术（假脱机技术）**

为了**缓和CPU和IO设备之间的速度差异**，引入脱机输入输出技术。**这是一项将独占设备改造成共享设备的技术。**

<img src="/assets/images/os.assets/image-20230613091111163.png" alt="image-20230613091111163" style="zoom:67%;" />

*简单来说，就是在磁盘上开辟一个空间，称为输入井和输出井，这俩就好玩了，**输出井在CPU面前假扮IO设备**，让CPU以为它已经将数据给了IO，CPU这个时候觉得哎呦不错哦，很快哦。实际上这个输出井只是默默接受CPU的输出，然后慢慢将其搞到IO上面。*

***输入井就是在IO面前扮演CPU**，输入井就一直收IO的信息，收集到一定程度之后才给CPU。*                       

使用高速磁盘，将独占设备改造为共享设备

输入井和输出井：输入井收容输入，输出井收容输出，输入输出文件各链接成输入输出队列

输入缓冲区和输出缓冲区：内存中，输入缓冲区暂存输入设备数据，输出缓冲区暂存输出井数据

输入进程和输出进程：模拟外围控制机，CPU输出数据经过内存送到输出井，CPU需要输入数据，输入井数据读入内存

**脱机系统的特点：**提高了io速度，将低速io转化为高速磁盘的数据存取；独占设备改为共享设备；设备虚拟化，每个进程认为自己独占了设备，其实是将文件挂在磁盘缓冲区队列上

## 5.3 磁盘

<img src="/assets/images/os.assets/image-20230613091136943.png" alt="image-20230613091136943" style="zoom:67%;" />

> 需要注意的是：磁盘的额存储能力受限于最内道的最大记录密度

磁盘地址：
$$
柱面号·盘面号·扇区号
$$
扇区是**最小的可寻址单位**。

### 磁盘的管理

**初始化：**将磁盘划**分为扇区**进行**数据结构的填充**，**低级格式化（物理格式化）**。一个扇区的数据结构通常包括头部，数据区域和尾部。

**分区：**

- 将磁盘划分为一个或者多个柱面组成的**分区**，每个分区的起始扇区和大小都记录在磁盘主引导记录中。
- （**逻辑格式化）**为每一个**分区创建文件系统**。

**引导块：**引导块的作用就是帮助系统运行，将必要的文件系统等信息载入内存。

<img src="/assets/images/os.assets/image-20230613091153558.png" alt="image-20230613091153558" style="zoom:67%;" />

> 这一部分的内容其实就是**文件管理**中的内容，因为磁盘本身就是文件系统的载体。

**坏块：**磁盘还会损坏并产生坏块。备用块逻辑地替代，**扇区备份**

具有坏扇区的磁道：备用扇区替换、移动所有扇区回避坏扇区

### **磁盘调度算法**

一次读写操作时间分为三个部分：**寻道时间，旋转延时，传输时间**

- **寻道时间$T_s$**。就是磁头移动到指定磁道所需要的时间。主要和跨越的磁道数有关，当然还包括启动磁臂的时间。

$$
T_s = m * n +s
$$

其中m是速度常数，启动时间s为常数

- **旋转延时$T_r$**

$$
T_r = \frac{1}{2r}
$$

r为磁盘旋转速度。

- **传输时间$T_t$**

$$
T_t = \frac{b}{rN}
$$

r为磁盘每秒的转数，N为一个磁道上面的字节数，b表示需要传输的字节数。

#### FCFS先来先服务

**公平**，接近随机调度

<img src="/assets/images/os.assets/image-20230613091209244.png" alt="image-20230613091209244" style="zoom:50%;" />

#### SSTF最短寻找时间优先

寻找需要与当前磁头位置距离最近的磁道的请求去执行。并不能保证总的平均寻找时间最小，但是会提供比FCFS较好的性能。会**产生“饥饿**”。

<img src="/assets/images/os.assets/image-20230613091225738.png" alt="image-20230613091225738" style="zoom:50%;" />

#### SCAN电梯调度

寻找**当前移动方向**上**最近**的磁道的请求来执行。**对扫描过的部分不公平**

<img src="/assets/images/os.assets/image-20230613091238363.png" alt="image-20230613091238363" style="zoom:50%;" />

> **磁头走到头**之后折返，并不是当前方向没有了就掉头

####  循环扫描

电梯算法是折返换一个方向找，这个算法是每一次**沿着单一方向走到头**之后**从0开始**，保持**方向不变**然后再扫描。

<img src="/assets/images/os.assets/image-20230613091249020.png" alt="image-20230613091249020" style="zoom:50%;" />

> 也就是说这两个扫描算法都是**严格从一端到另一端**。

#### Look调度和CLook调度

改进了扫描算法，**不用走到头了**。

<img src="/assets/images/os.assets/image-20230613091302951.png" alt="image-20230613091302951" style="zoom:50%;" />

<img src="/assets/images/os.assets/image-20230613091314001.png" alt="image-20230613091314001" style="zoom:50%;" />

> 要注意区分这里的CLook和页面调度算法的CLOCK算法。俩个真的是不同的，名字都不一样。

![image-20230613091333512](/assets/images/os.assets/image-20230613091333512.png)

### CLOCK定时器

维护日时间的三种方式：64位计数器、32位计数器和辅助计数器、32位对滴答计数器



**CPU和设备控制器的寄存器、缓冲区通行：**端口和内存地址空间的映射

**内存映射IO的优点：**代码用C语言不用汇编、不需要特殊的保护机制隔离用户进程、内存指令直接控制设备寄存器、映射页面禁止高速缓存

**精确中断和非精确中断：**

相比于中断，DMA的优势在于：打印字符没打印一个缓冲区才中断一次

**IO软件的目标：**

- 设备独立性：程序可以访问任意设备，不需要提前知道设备
- 统一命名：设备统一命名为字符串或者整数，不依赖于特定的设备
- 错误处理：经可能在硬件上进行错误处理
- 同步和异步：中断驱动
- 缓冲：放在缓冲区
- 共享设备和独占设备：脱机打印技术

**设备无关IO软件：**为设备提供统一接口、缓冲、差错控制、提供设备无关的块大小、分配和释放设备

缓冲是一种缓解速度差异的技术，太多缓冲会降低性能

> 设备独立性、、缓冲、共享和独占、统一命名、错误控制、同步异步

**IO软件层次：**

![image-20230701204014018](/assets/images/5.IO管理.assets/image-20230701204014018.png)

**RAID廉价磁盘冗余阵列**

数据分布在全部驱动器上，可以并行操作

**柱面斜进：**在一次寻道时间内，磁盘旋转的扇区数量成为柱面斜进量





