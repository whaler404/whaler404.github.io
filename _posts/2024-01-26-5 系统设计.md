---
layout: post
title:  系统设计
# subtitle: 
date:   2024-01-26
author: fzy
header-img: img/post-bg-playphone.jpg
categories: post course
catalog: true
tags:
    - course
    - software engineer
---

# 	第5章：系统设计

## 系统设计概述

系统设计是一个两部分的迭代过程：

>概要设计就像是在地图上规划一条旅行路线，确定主要的城市和途经的方向（主要模块和组件，定义模块之间的接口，以及确定整体的数据流和控制流），
>
>而详细设计则是在每个城市中详细规划具体的行进路线、停留点和行为（数据结构、算法、函数和子程序）

-   概要设计：设计软件的结构，把软件按照一定的原则**分解为模块层次**，赋予每个模块一定的任务，并确定模块间的**调用关系和接口**。得到**软件结构图或者架构图**
-   详细设计：对概要设计的一个细化，详细设计每个模块**实现算法**，将功能描述变为精确的、结构化的过程描述。得到**详细设计说明书**



## 好的设计的特征

### 耦合度

-   高度耦合：两个构件之间有大量依赖关系的时候
-   松散耦合：两个构件具有某种程度的依赖，但他们的相互连接比较弱
-   非耦合：构件之间不存在相互连接

#### 耦合度的类型

- 内容耦合：当一个构件修改了另一个构件的内部数据项的时候，或者一个构件内的分支转移到另一个构件中的时候，可能出现内容耦合。

  >一个模块直接修改另一个模块中的全局变量。

  <img src="/assets/images/软件工程.assets/image-20231206195854896.png" alt="image-20231206195854896" style="zoom:50%;" />

- 公共耦合：对公共数据的改变

  > 假设有一个系统，其中多个模块都共享同一个**全局配置文件**，包含系统的一些基本配置信息。
  >
  > 如果需要修改这个全局配置文件中的某项设置，那么所有依赖这个配置文件的模块都可能受到影响。

<img src="/assets/images/软件工程.assets/image-20231206195920715.png" alt="image-20231206195920715" style="zoom:50%;" />

>1. **数据耦合（Data Coupling）：**
>   - **描述：** 模块之间通过参数传递简单的数据类型，如基本数据类型或数据结构。一个模块将数据传递给另一个模块，但不关心数据的内部结构。
>   - **例子：** 一个计算模块接收两个数字并返回它们的和。
>2. **控制耦合（Control Coupling）：**
>   - **描述：** 一个模块通过传递控制信息，如标志或状态，影响另一个模块的执行流程。两个模块之间存在一定程度的控制关系。
>   - **例子：** 一个模块调用另一个模块，并传递一个标志，根据标志的值来决定执行的路径。
>3. **标记耦合（Stamp Coupling）：**
>   - **描述：** 两个模块之间通过共享复杂的数据结构或记录进行通信，但只使用其中的一部分信息。
>   - **例子：** 一个模块传递一个包含多个字段的记录给另一个模块，但只使用其中的几个字段。
>4. **内容耦合（Content Coupling）：**
>   - **描述：** 两个模块之间共享了内部的实现细节，一个模块直接访问另一个模块的内部数据结构或方法。
>   - **例子：** 一个模块直接修改另一个模块中的全局变量。

### 内聚

如果构件的所有元素都是直接面向执行同一个任务的并且必须的，那么该构件是内聚的。

> 内聚描述了一个**模块内**各个部分（（如函数、类、模块等））彼此之间有多么**密切地关联**。
>
> 高内聚意味着一个模块内的元素在**逻辑上**紧密结合，完成的是**相似的任务**。
>
> 1. **内聚强调模块内部的关联性** 
> 2. **耦合强调模块之间的关系** 
>
> **高内聚低耦合：** 表示模块内部各个元素关联紧密，同时不同模块之间相对独立。这是一个理想的设计目标，有助于提高代码的质量和可维护性。

内聚的类型：

<img src="/assets/images/软件工程.assets/image-20231206200032129.png" alt="image-20231206200032129" style="zoom:50%;" />

<img src="/assets/images/软件工程.assets/image-20231206200103390.png" alt="image-20231206200103390" style="zoom:50%;" />

>1. **偶然性内聚（Coincidental Cohesion）：**
>   - **描述：** 模块内的元素没有明显的关联，它们仅仅因为偶然地在同一个模块中，没有共同的目标或任务。
>   - **例子：** 一个包含了无关功能的**杂乱函数库**。
>2. **逻辑内聚（Logical Cohesion）：**
>   - **描述：** 模块内的元素在逻辑上相关，共同完成一个清晰的任务或目标。
>   - **例子：** 一个处理**用户认证的模块**，包含验证用户名、检查密码等**相关逻辑**。
>3. **时间内聚（Temporal Cohesion）：**
>   - **描述：** 模块内的元素在时间上相关，它们在同一时间段内执行，但没有直接关联。
>   - **例子：** 一个包含了**每周执行的一系列任务的模块**。
>4. **过程内聚（Procedural Cohesion）：**
>   - **描述：** 模块内的元素按照一定的顺序执行，它们共同参与完成一个过程或任务。
>   - **例子：** 一个**按顺序执行**文件读取、处理和写入的**数据处理模块**。
>5. **功能内聚（Functional Cohesion）：**
>   - **描述：** 模块内的元素按照功能相似性相关联，共同完成一个功能。
>   - **例子：** 一个**负责计算数学函数的模块**，包含加法、减法等相关功能。
>6. **顺序内聚（Sequential Cohesion）：**
>   - **描述：** 模块内的元素按照顺序执行，一个元素的输出作为下一个元素的输入。
>   - **例子：** 一个**数据处理模块**，包含按照顺序执行的数据转换步骤。
>7. **交互内聚（Communicational Cohesion）：**
>   - **描述：** 模块内的元素共享相同的数据，但没有直接的逻辑关联。
>   - **例子：** 一个模块包含了**对共享数据的**读取和写入**操作**，但这些**操作之间没有直接关联**。



## 改善设计的方法

-   降低复杂性（**高内聚低耦合**）
-   按**合同**设计
-   **原型化**设计：详细见需求分析中提及的原型化的优点
-   **故障树**分析：标识可能的失败，构造图，用节点表示失败，边表示节点之间的关系。
-   **文档化**设计：设计合理性，系统架构的描述，用户如何与系统进行交互。

>故障树（Fault Tree）：图形化工具，用于描述系统故障发生的可能性和原因。
>
>考虑一个飞机系统的故障树，**顶事件**可能是“飞机系统失效”。通过**逻辑门**和**基本事件**的组合，可以得到不同的**逻辑路径**，如“引擎故障”、"油料耗尽"、"电气系统故障"等。这些基本事件再可以**进一步分解**，比如“引擎故障”可以分解为“涡轮故障”、“点火系统故障”等。通过分析这些逻辑路径，我们可以识别导致整个系统失效的潜在原因。
>
>改善设计的方法：高内聚低耦合、合同、原型化、故障树、文档化



